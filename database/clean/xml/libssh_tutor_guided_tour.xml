<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="libssh_tutor_guided_tour" kind="page">
    <compoundname>libssh_tutor_guided_tour</compoundname>
    <title>Chapter 1: A typical SSH session</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="libssh_tutor_guided_tour_1ssh_session">
<title>A typical SSH session</title>
<para>A SSH session goes through the following steps:</para>
<para><itemizedlist>
<listitem><para>Before connecting to the server, you can set up if you wish one or other server public key authentication, i.e. DSA or RSA. You can choose cryptographic algorithms you trust and compression algorithms if any. You must of course set up the hostname.</para>
</listitem><listitem><para>The connection is established. A secure handshake is made, and resulting from it, a public key from the server is gained. You MUST verify that the public key is legitimate, using for instance the MD5 fingerprint or the known hosts file.</para>
</listitem><listitem><para>The client must authenticate: the classical ways are password, or public keys (from dsa and rsa key-pairs generated by openssh). If a SSH agent is running, it is possible to use it.</para>
</listitem><listitem><para>Now that the user has been authenticated, you must open one or several channels. Channels are different subways for information into a single ssh connection. Each channel has a standard stream (stdout) and an error stream (stderr). You can theoretically open an infinity of channels.</para>
</listitem><listitem><para>With the channel you opened, you can do several things:<itemizedlist>
<listitem><para>Execute a single command.</para>
</listitem><listitem><para>Open a shell. You may want to request a pseudo-terminal before.</para>
</listitem><listitem><para>Invoke the sftp subsystem to transfer files.</para>
</listitem><listitem><para>Invoke the scp subsystem to transfer files.</para>
</listitem><listitem><para>Invoke your own subsystem. This is outside the scope of this document, but can be done.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>When everything is finished, just close the channels, and then the connection.</para>
</listitem></itemizedlist>
</para>
<para>The sftp and scp subsystems use channels, but libssh hides them to the programmer. If you want to use those subsystems, instead of a channel, you&apos;ll usually open a &quot;sftp session&quot; or a &quot;scp session&quot;.</para>
<sect2 id="libssh_tutor_guided_tour_1setup">
<title>Creating the session and setting options</title>
<para>The most important object in a SSH connection is the SSH session. In order to allocate a new SSH session, you use <ref refid="group__libssh__session_1gaadadc0f9601547c30db7c4d62017d32c" kindref="member">ssh_new()</ref>. Don&apos;t forget to always verify that the allocation succeeded. <programlisting><codeline><highlight class="normal">#include<sp/>&lt;libssh/libssh.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdlib.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_session<sp/>my_ssh_session<sp/>=<sp/>ssh_new();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(my_ssh_session<sp/>==<sp/>NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>libssh follows the allocate-it-deallocate-it pattern. Each object that you allocate using xxxxx_new() must be deallocated using xxxxx_free(). In this case, <ref refid="group__libssh__session_1gaadadc0f9601547c30db7c4d62017d32c" kindref="member">ssh_new()</ref> does the allocation and <ref refid="group__libssh__session_1gae5af27a98a7488e9f5ded6b37c274156" kindref="member">ssh_free()</ref> does the contrary.</para>
<para>The <ref refid="group__libssh__session_1ga7a801b85800baa3f4e16f5b47db0a73d" kindref="member">ssh_options_set()</ref> function sets the options of the session. The most important options are:<itemizedlist>
<listitem><para>SSH_OPTIONS_HOST: the name of the host you want to connect to</para>
</listitem><listitem><para>SSH_OPTIONS_PORT: the used port (default is port 22)</para>
</listitem><listitem><para>SSH_OPTIONS_USER: the system user under which you want to connect</para>
</listitem><listitem><para>SSH_OPTIONS_LOG_VERBOSITY: the quantity of messages that are printed</para>
</listitem></itemizedlist>
</para>
<para>The complete list of options can be found in the documentation of <ref refid="group__libssh__session_1ga7a801b85800baa3f4e16f5b47db0a73d" kindref="member">ssh_options_set()</ref>. The only mandatory option is SSH_OPTIONS_HOST. If you don&apos;t use SSH_OPTIONS_USER, the local username of your account will be used.</para>
<para>Here is a small example of how to use it:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;libssh/libssh.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdlib.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_session<sp/>my_ssh_session;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>verbosity<sp/>=<sp/>SSH_LOG_PROTOCOL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>port<sp/>=<sp/>22;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_ssh_session<sp/>=<sp/>ssh_new();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(my_ssh_session<sp/>==<sp/>NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_options_set(my_ssh_session,<sp/>SSH_OPTIONS_HOST,<sp/>&quot;localhost&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_options_set(my_ssh_session,<sp/>SSH_OPTIONS_LOG_VERBOSITY,<sp/>&amp;verbosity);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_options_set(my_ssh_session,<sp/>SSH_OPTIONS_PORT,<sp/>&amp;port);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Please notice that all parameters are passed to <ref refid="group__libssh__session_1ga7a801b85800baa3f4e16f5b47db0a73d" kindref="member">ssh_options_set()</ref> as pointers, even if you need to set an integer value.</para>
<para><simplesect kind="see"><para><ref refid="group__libssh__session_1gaadadc0f9601547c30db7c4d62017d32c" kindref="member">ssh_new</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1gae5af27a98a7488e9f5ded6b37c274156" kindref="member">ssh_free</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga7a801b85800baa3f4e16f5b47db0a73d" kindref="member">ssh_options_set</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga82371e723260c7572ea061edecc2e9f1" kindref="member">ssh_options_parse_config</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1gaead8cef1f39e785139bc510852ce1dff" kindref="member">ssh_options_copy</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga93f7f7159893f3ce62c9b178724eff75" kindref="member">ssh_options_getopt</ref></para>
</simplesect>
</para>
</sect2>
<sect2 id="libssh_tutor_guided_tour_1connect">
<title>Connecting to the server</title>
<para>Once all settings have been made, you can connect using <ref refid="group__libssh__session_1ga032e07cbd8bc3f14cb2dd375db0b03d7" kindref="member">ssh_connect()</ref>. That function will return SSH_OK if the connection worked, SSH_ERROR otherwise.</para>
<para>You can get the English error string with <ref refid="group__libssh__error_1ga9241586665bf21f823806473fc386258" kindref="member">ssh_get_error()</ref> in order to show the user what went wrong. Then, use <ref refid="group__libssh__session_1ga0f048a4c0dbe02cfb7e9c5b6d0db0f27" kindref="member">ssh_disconnect()</ref> when you want to stop the session.</para>
<para>Here&apos;s an example:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;libssh/libssh.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdlib.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdio.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_session<sp/>my_ssh_session;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_ssh_session<sp/>=<sp/>ssh_new();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(my_ssh_session<sp/>==<sp/>NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_options_set(my_ssh_session,<sp/>SSH_OPTIONS_HOST,<sp/>&quot;localhost&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>ssh_connect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(rc<sp/>!=<sp/>SSH_OK)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Error<sp/>connecting<sp/>to<sp/>localhost:<sp/>%s\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_get_error(my_ssh_session));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_disconnect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="libssh_tutor_guided_tour_1serverauth">
<title>Authenticating the server</title>
<para>Once you&apos;re connected, the following step is mandatory: you must check that the server you just connected to is known and safe to use (remember, SSH is about security and authentication).</para>
<para>There are two ways of doing this:<itemizedlist>
<listitem><para>The first way (recommended) is to use the <ref refid="group__libssh__session_1gacbc5d04fe66beee863a0c61a93fdf765" kindref="member">ssh_session_is_known_server()</ref> function. This function will look into the known host file (~/.ssh/known_hosts on UNIX), look for the server hostname&apos;s pattern, and determine whether this host is present or not in the list.</para>
</listitem><listitem><para>The second way is to use <ref refid="group__libssh__session_1gaf8ff0e2236d54d964a82f68d7323a741" kindref="member">ssh_get_pubkey_hash()</ref> to get a binary version of the public key hash value. You can then use your own database to check if this public key is known and secure.</para>
</listitem></itemizedlist>
</para>
<para>You can also use the <ref refid="group__libssh__session_1gaf8ff0e2236d54d964a82f68d7323a741" kindref="member">ssh_get_pubkey_hash()</ref> to show the public key hash value to the user, in case he knows what the public key hash value is (some paranoid people write their public key hash values on paper before going abroad, just in case ...).</para>
<para>If the remote host is being used to for the first time, you can ask the user whether he/she trusts it. Once he/she concluded that the host is valid and worth being added in the known hosts file, you use <ref refid="group__libssh__session_1gaf61a9cfdc40c76ffce9f9a8543755d36" kindref="member">ssh_write_knownhost()</ref> to register it in the known hosts file, or any other way if you use your own database.</para>
<para>The following example is part of the examples suite available in the examples/ directory:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;errno.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;string.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>verify_knownhost(ssh_session<sp/>session)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>enum<sp/>ssh_known_hosts_e<sp/>state;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>unsigned<sp/>char<sp/>*hash<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_key<sp/>srv_pubkey<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>hlen;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char<sp/>buf[10];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char<sp/>*hexa;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>char<sp/>*p;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>cmp;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc<sp/>=<sp/>ssh_get_server_publickey(session,<sp/>&amp;srv_pubkey);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rc<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc<sp/>=<sp/>ssh_get_publickey_hash(srv_pubkey,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SSH_PUBLICKEY_HASH_SHA1,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;hash,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;hlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_key_free(srv_pubkey);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(rc<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>state<sp/>=<sp/>ssh_session_is_known_server(session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(state)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_OK:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>OK<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_CHANGED:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Host<sp/>key<sp/>for<sp/>server<sp/>changed:<sp/>it<sp/>is<sp/>now:\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_print_hexa(&quot;Public<sp/>key<sp/>hash&quot;,<sp/>hash,<sp/>hlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;For<sp/>security<sp/>reasons,<sp/>connection<sp/>will<sp/>be<sp/>stopped\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_clean_pubkey_hash(&amp;hash);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_OTHER:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;The<sp/>host<sp/>key<sp/>for<sp/>this<sp/>server<sp/>was<sp/>not<sp/>found<sp/>but<sp/>an<sp/>other&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;type<sp/>of<sp/>key<sp/>exists.\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;An<sp/>attacker<sp/>might<sp/>change<sp/>the<sp/>default<sp/>server<sp/>key<sp/>to&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;confuse<sp/>your<sp/>client<sp/>into<sp/>thinking<sp/>the<sp/>key<sp/>does<sp/>not<sp/>exist\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_clean_pubkey_hash(&amp;hash);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_NOT_FOUND:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Could<sp/>not<sp/>find<sp/>known<sp/>host<sp/>file.\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;If<sp/>you<sp/>accept<sp/>the<sp/>host<sp/>key<sp/>here,<sp/>the<sp/>file<sp/>will<sp/>be&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;automatically<sp/>created.\n&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/*<sp/>FALL<sp/>THROUGH<sp/>to<sp/>SSH_SERVER_NOT_KNOWN<sp/>behavior<sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_UNKNOWN:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hexa<sp/>=<sp/>ssh_get_hexa(hash,<sp/>hlen);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,&quot;The<sp/>server<sp/>is<sp/>unknown.<sp/>Do<sp/>you<sp/>trust<sp/>the<sp/>host<sp/>key?\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Public<sp/>key<sp/>hash:<sp/>%s\n&quot;,<sp/>hexa);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_string_free_char(hexa);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_clean_pubkey_hash(&amp;hash);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p<sp/>=<sp/>fgets(buf,<sp/>sizeof(buf),<sp/>stdin);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(p<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cmp<sp/>=<sp/>strncasecmp(buf,<sp/>&quot;yes&quot;,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(cmp<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rc<sp/>=<sp/>ssh_session_update_known_hosts(session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(rc<sp/>&lt;<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Error<sp/>%s\n&quot;,<sp/>strerror(errno));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>SSH_KNOWN_HOSTS_ERROR:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Error<sp/>%s&quot;,<sp/>ssh_get_error(session));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_clean_pubkey_hash(&amp;hash);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_clean_pubkey_hash(&amp;hash);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="group__libssh__session_1ga032e07cbd8bc3f14cb2dd375db0b03d7" kindref="member">ssh_connect</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga0f048a4c0dbe02cfb7e9c5b6d0db0f27" kindref="member">ssh_disconnect</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__error_1ga9241586665bf21f823806473fc386258" kindref="member">ssh_get_error</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__error_1ga036433b7bf3d4ca94206253f58d136f9" kindref="member">ssh_get_error_code</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga5342eefee0497636e9657c968e106782" kindref="member">ssh_get_server_publickey</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga7a7b16a4bed6d8d58f10bdb269172ff7" kindref="member">ssh_get_publickey_hash</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1gacbc5d04fe66beee863a0c61a93fdf765" kindref="member">ssh_session_is_known_server</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="group__libssh__session_1ga958fdd1aedcd85a5c496c0aa22362d34" kindref="member">ssh_session_update_known_hosts</ref></para>
</simplesect>
</para>
</sect2>
<sect2 id="libssh_tutor_guided_tour_1auth">
<title>Authenticating the user</title>
<para>The authentication process is the way a service provider can identify a user and verify his/her identity. The authorization process is about enabling the authenticated user the access to resources. In SSH, the two concepts are linked. After authentication, the server can grant the user access to several resources such as port forwarding, shell, sftp subsystem, and so on.</para>
<para>libssh supports several methods of authentication:<itemizedlist>
<listitem><para>&quot;none&quot; method. This method allows to get the available authentications methods. It also gives the server a chance to authenticate the user with just his/her login. Some very old hardware uses this feature to fallback the user on a &quot;telnet over SSH&quot; style of login.</para>
</listitem><listitem><para>password method. A password is sent to the server, which accepts it or not.</para>
</listitem><listitem><para>keyboard-interactive method. The server sends several challenges to the user, who must answer correctly. This makes possible the authentication via a codebook for instance (&quot;give code at 23:R on page 3&quot;).</para>
</listitem><listitem><para>public key method. The host knows the public key of the user, and the user must prove he knows the associated private key. This can be done manually, or delegated to the SSH agent as we&apos;ll see later.</para>
</listitem></itemizedlist>
</para>
<para>All these methods can be combined. You can for instance force the user to authenticate with at least two of the authentication methods. In that case, one speaks of &quot;Partial authentication&quot;. A partial authentication is a response from authentication functions stating that your credential was accepted, but yet another one is required to get in.</para>
<para>The example below shows an authentication with password:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;libssh/libssh.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdlib.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdio.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_session<sp/>my_ssh_session;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>*password;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Open<sp/>session<sp/>and<sp/>set<sp/>options</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>my_ssh_session<sp/>=<sp/>ssh_new();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(my_ssh_session<sp/>==<sp/>NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_options_set(my_ssh_session,<sp/>SSH_OPTIONS_HOST,<sp/>&quot;localhost&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Connect<sp/>to<sp/>server</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>ssh_connect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(rc<sp/>!=<sp/>SSH_OK)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Error<sp/>connecting<sp/>to<sp/>localhost:<sp/>%s\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_get_error(my_ssh_session));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Verify<sp/>the<sp/>server&apos;s<sp/>identity</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>For<sp/>the<sp/>source<sp/>code<sp/>of<sp/>verify_knownhost(),<sp/>check<sp/>previous<sp/>example</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(verify_knownhost(my_ssh_session)<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_disconnect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Authenticate<sp/>ourselves</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>password<sp/>=<sp/>getpass(&quot;Password:<sp/>&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>ssh_userauth_password(my_ssh_session,<sp/>NULL,<sp/>password);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(rc<sp/>!=<sp/>SSH_AUTH_SUCCESS)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/>&quot;Error<sp/>authenticating<sp/>with<sp/>password:<sp/>%s\n&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ssh_get_error(my_ssh_session));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_disconnect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_disconnect(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_free(my_ssh_session);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="see"><para><ref refid="libssh_tutor_authentication_1authentication_details" kindref="member">A deeper insight on authentication</ref></para>
</simplesect>
</para>
</sect2>
<sect2 id="libssh_tutor_guided_tour_1using_ssh">
<title>Doing something</title>
<para>At this point, the authenticity of both server and client is established. Time has come to take advantage of the many possibilities offered by the SSH protocol: execute a remote command, open remote shells, transfer files, forward ports, etc.</para>
<para>The example below shows how to execute a remote command:</para>
<para><programlisting><codeline><highlight class="normal">int<sp/>show_remote_processes(ssh_session<sp/>session)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_channel<sp/>channel;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>char<sp/>buffer[256];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>nbytes;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>channel<sp/>=<sp/>ssh_channel_new(session);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(channel<sp/>==<sp/>NULL)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>SSH_ERROR;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>ssh_channel_open_session(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(rc<sp/>!=<sp/>SSH_OK)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_channel_free(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>ssh_channel_request_exec(channel,<sp/>&quot;ps<sp/>aux&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(rc<sp/>!=<sp/>SSH_OK)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_channel_close(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_channel_free(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>rc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>nbytes<sp/>=<sp/>ssh_channel_read(channel,<sp/>buffer,<sp/>sizeof(buffer),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(nbytes<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(write(1,<sp/>buffer,<sp/>nbytes)<sp/>!=<sp/>(unsigned<sp/>int)<sp/>nbytes)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ssh_channel_close(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ssh_channel_free(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>SSH_ERROR;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nbytes<sp/>=<sp/>ssh_channel_read(channel,<sp/>buffer,<sp/>sizeof(buffer),<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(nbytes<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_channel_close(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ssh_channel_free(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>SSH_ERROR;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_channel_send_eof(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_channel_close(channel);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ssh_channel_free(channel);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>SSH_OK;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Each <ref refid="group__libssh__channel_1ga567d509183ade0a77190f390e2b5747d" kindref="member">ssh_channel_request_exec()</ref> needs to be run on freshly created and connected (with <ref refid="group__libssh__channel_1gaf051dd30d75bf6dc45d1a5088cf970bd" kindref="member">ssh_channel_open_session()</ref>) channel.</para>
<para><simplesect kind="see"><para><ref refid="libssh_tutor_shell_1opening_shell" kindref="member">Opening a remote shell</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="libssh_tutor_command_1remote_command" kindref="member">Passing a remote command</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="libssh_tutor_sftp_1sftp_subsystem" kindref="member">The SFTP subsystem</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="libssh_tutor_scp_1scp_subsystem" kindref="member">The SCP subsystem</ref></para>
</simplesect>
</para>
</sect2>
<sect2 id="libssh_tutor_guided_tour_1errors">
<title>Handling the errors</title>
<para>All the libssh functions which return an error value also set an English error message describing the problem.</para>
<para>Error values are typically SSH_ERROR for integer values, or NULL for pointers.</para>
<para>The function <ref refid="group__libssh__error_1ga9241586665bf21f823806473fc386258" kindref="member">ssh_get_error()</ref> returns a pointer to the static error message.</para>
<para>ssh_error_code() returns the error code number : SSH_NO_ERROR, SSH_REQUEST_DENIED, SSH_INVALID_REQUEST, SSH_CONNECTION_LOST, SSH_FATAL, or SSH_INVALID_DATA. SSH_REQUEST_DENIED means the ssh server refused your request, but the situation is recoverable. The others mean something happened to the connection (some encryption problems, server problems, ...). SSH_INVALID_REQUEST means the library got some garbage from server, but might be recoverable. SSH_FATAL means the connection has an important problem and isn&apos;t probably recoverable.</para>
<para>Most of time, the error returned are SSH_FATAL, but some functions (generally the ssh_request_xxx ones) may fail because of server denying request. In these cases, SSH_REQUEST_DENIED is returned.</para>
<para>For thread safety, errors are bound to ssh_session objects. As long as your ssh_session object is not NULL, you can retrieve the last error message and error code from the ssh_session using <ref refid="group__libssh__error_1ga9241586665bf21f823806473fc386258" kindref="member">ssh_get_error()</ref> and <ref refid="group__libssh__error_1ga036433b7bf3d4ca94206253f58d136f9" kindref="member">ssh_get_error_code()</ref> respectively.</para>
<para>The SFTP subsystem has its own error codes, in addition to libssh ones. </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="doc/guided_tour.dox"/>
  </compounddef>
</doxygen>
